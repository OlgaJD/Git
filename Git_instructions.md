# Инструкция по работе с Git. 

Перед началом работы с git необходимо авторизоваться, указав имя и электронную почту с помощью команд:
1. git config --global user.name
2. git config --global user.email

## Основные команды Git:

**git --version** - показывает текущую версию Git.

**git init** - cоздание репозитория из обычной папки. _Выполняется всего 1 раз_.

**git status** - показывает текущее состояние в репозитории, отображает также файлы недобавленные к отслеживанию. _Q  - выход из области просмотра (англ.раскладка)_.

**git add file_name** - добавить файл в отслеживаемые Git. _При помощи кнопкой Tab название заполняется автоматически_.

**git add .**  - добавить в отслеживаемые Git все файлы находящие в папке репозитория.

**git commit -m ”save_message”** - сохранение (фиксация) файла. В кавычках указывается комментарий к сохранению.

**git commit -am “save_message”** - объединяет две команды: git add и git commit - m.

**git log** - показывает журнал последних коммитов (сохранений).

**Q**  - выходит из области просмотра.

**git reflog и git log --oneline** - обе команды показывают полный журнал коммитов (сохранений) в сокращенном виде.

**git checkout commit или branch** - переход к необходимой версии коммита или ветке. Имя коммита можно указать полностью или его первые 4 символа. branch - указываем имя ветки (переходит на последний коммит ветки, он совпадает с именем этой ветки).

**git checkout branchname^** - переход на коммит выше от указанной ветки(^^ - на 2 коммита выше)

**git checkout master** - возврат к самой актуальной версии.

**git checkout branchname ~ number** - переместиться на несколько шагов назад по дереву. Можно добавить количество родительских коммитов, через которые нужно пройти после знака ~.

**git diff** - показывает разницу между текущим состоянием файла и сохраненным ранее (сравнивает записанные версии файла).

**git diff com1 com2** -показывает разницу между двумя сравниваемыми коммитами, где com1 и com2 можно указать полное имя коммита или его первые 4 символа.

**git help** - помощь по базовым командам Git.

**clear** - очистить терминал.

## Игнорирование файлов:

* Создаем в папке новый файл с именем **.gitignore**, вносим в него все наименования файлов, которые хотим игнорировать, сохраняем обычным способом git add .gitignore, git commit -m “save_message”.

*  *.формат файла - добавляем в игнор все файлы с указанным расширением находящиеся в папке, например * .jpeg (без пробела) добавит в игнор все картинки.*

* bin/  - игнорировать подпапку bin со всем содержимым.

*Игнорируемые файлы отображаются серыми цветом в VSCode.*

## Ветки, слияние и перемещение веток:

**git branch** - показывает все созданные (неудаленные) ветки.

**git branch branchname** - создание новой ветки, где namebranch - имя новой ветки.

**git checkout - b branchname -** создает новую ветку и сразу в нее перемещается.

**git merge branch** - слияние двух веток, где branch имя ветки, которую будем вливать. Вызываем команду из той ветки, куда хотим залить новую. 

**git merge --abort** - откатывает слияние веток.

**git branch -d branchname -** удалить ветку, где branchname - имя ветки.

**git branch - f branchname  hash ~number -** напрямую прикрепить ветку к коммиту без переходов на эти коммиты, где branchname - ветка которую будем прикреплять, hash - коммит к которому будем прикреплять ветку,  ~number - на сколько шагов вверх от указанного коммита. Можно использовать без шагов **~number .** Быстро переставляет ветки без перемещения, будет работать даже если есть незафиксированные изменения.

**git rebase branchname** - объединение коммитов веток (перемещение веток). Объединяет ветку (делает ее копию) на которой находимся с последним коммитом нужной ветки.  Делает линейные последовательные коммиты.

**git rebase --abort** - отмена процесса rebase перемещения веток.

**git cherry-pick hash hash hash** - объединение нескольких выбранных коммитов за раз в одну ветку, hash нужные коммиты

*Слияние с конфликтами:*

При слиянии веток иногда возникают конфликты. Необходимо выбрать нужный вариант или объединить обе ветки в одну, затем закоммитить.

## Отмена изменений:

**git reset** - отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории”. Переносит ветку назад, как будто некоторых коммитов вовсе и не было. *Работает на локальных ветках.*

**git revert** отменить изменения, при этом появляется новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в отменяемом коммите.

## Работа с удаленными репозиториями:

**Основные команды:**

**git clone link** - копировать удаленный репозиторий из сервиса github в локальный.

**cd folder_name** - поменять папку-католог (change directory) - переход в нужную папку при работе в программе, где folder_name нужная папка с которой будем работать.

**cd ..** - переместиться в корневую папку.

**git pull** - синхронизация с удаленным репозиторием (загружает содержимое из удаленного репозитория в локальную версию) сразу мержит версии.

**git fetch** - загружает содержимое из указанного удаленного репозитория в локальный, но не мержит.

**git push** - направляет созданный локальный репозиторий или все его изменения (если уже работаем с этим репозиторием) в удаленный.

_Для работы с **pull requests:**_

**fork** - в сервисе github - полная копия чужого репозитория на свой аккаунт githab.

_**Копирование удаленного репозитория в локальный:**_

1. Папка в которую копируем не должна быть репозиторием.
2. На странице github копируем ссылку по кнопке code.
3. **git clone saved_link** - вводим в терминал VSCode, где saved_link - копированная ссылка из сервиса github.
4. **cd folder_name** - переходим в новую нужную папку.

_**Размещение локального репозитория на сервере github:**_

1. Создаем / загружаем папку с нужным репозиторий в VSCode.
2. В сервисе github создаем репозиторий, присваиваем ему имя. Github предложит варианты создания нового репозитория, выбираем нужный вариант, и следуем инструкции.
3. *Для размещения из локального репозитория на сервис:* копируем строки из github в VSCode:
- **git remote add origin link** - этим мы связываем локальный и удаленный аккаунт, где link - ссылка, на созданный удаленный репозиторий (автоматически предлагается сервисом для копирования).
- **git branch -M main** - показывает, какая ветка будет являться основной. В локальном репозитории будет master, в сервисе эта ветка будет main.
- **git push -u origin main** - направляем локальный репозиторий в сервис github (авторизовываемся, если первый раз).

*При создании нового репозитория можно скопировать сразу все 3 строки из сервиса github и вставить в код терминала.*

Далее для работы над одним проектом в удалнном и локальном одновременно команды:

**git push -** для отправки изменений в удаленный репозиторий из локального.

**git pull** - для выкачки и слияния изменений из удаленного репозитория в локальный.

_**Работа с pull requests. Предлагаем изменения к чужому репозиторию:**_

1. Выполняем команду **fork** интересующего нас репозитория в свой аккаунт github.
2. Копируем ссылку репозитория по кнопке code.
3. **git clone saved_link** - клонируем удаленный репозиторий в локальный.
4. **cd folder_name** - переходим в нужную папку.
5. Создаем новую ветку и новый файл в ней README.md, в котором описываем изменения и предложения. *Производим все изменения только в этой ветке.*
6. Комитим файл в локальном репозитории.
7. **git push** - направляем  изменения из локального репозитория в сервис githab на свой аккаунт. В сервисе появляется функция **Compare & pull request** - предложить нашу ветку с изменениями автору основного репозитория.
8. Добавляем описание предложения, отправляем (в окне на git hub появляется возможность отправить pull request  с изменениями).

*Автор может влить предлагаемую ветку в свой проект или отказаться от изменений.*
